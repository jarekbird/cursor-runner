name: Deploy cursor-runner

on:
  push:
    branches:
      - master
      - main
  workflow_dispatch:  # Allows manual trigger from GitHub UI

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only run if the push is to the main branch
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        env:
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script: |
            set -e
            
            # Initialize Docker resources (network and volumes) if they don't exist
            echo "Initializing Docker resources..."
            
            # Create network if it doesn't exist
            if ! docker network ls | grep -q "virtual-assistant-network"; then
              echo "Creating virtual-assistant-network..."
              docker network create virtual-assistant-network || true
            fi
            
            # Create shared SQLite database volume if it doesn't exist
            if ! docker volume inspect shared_sqlite_db >/dev/null 2>&1; then
              echo "Creating shared_sqlite_db volume..."
              docker volume create shared_sqlite_db || true
            fi
            
            # Create shared Redis data volume if it doesn't exist
            if ! docker volume inspect shared_redis_data >/dev/null 2>&1; then
              echo "Creating shared_redis_data volume..."
              docker volume create shared_redis_data || true
            fi
            
            # Create cursor-runner repositories volume if it doesn't exist
            if ! docker volume inspect cursor_runner_repositories >/dev/null 2>&1; then
              echo "Creating cursor_runner_repositories volume..."
              docker volume create cursor_runner_repositories || true
            fi
            
            # Navigate to cursor-runner directory
            cd cursor-runner || { echo "Directory cursor-runner not found"; exit 1; }
            
            # Update code
            git fetch origin || { echo "Git fetch failed"; exit 1; }
            BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
            git reset --hard origin/$BRANCH || { echo "Git reset failed"; exit 1; }
            
            # Build the container first
            docker compose build cursor-runner || { echo "Docker build failed"; exit 1; }
            
            # Merge MCP configuration with existing repositories mcp.json
            # Run the script in the cursor-runner container we just built
            # This container has Node.js and the repositories volume mounted at /app/repositories
            echo "Merging MCP configuration..."
            if [ -f "merge-mcp-config.js" ]; then
              # Use docker compose run to use the service configuration (volumes, etc.)
              # Override the CMD to run our merge script instead of starting the server
              docker compose run --rm --no-deps \
                -w /app \
                cursor-runner \
                node merge-mcp-config.js || { echo "Warning: MCP config merge failed, continuing deployment"; }
            else
              echo "Warning: merge-mcp-config.js not found, skipping MCP config merge"
            fi
            
            # Deploy the container
            # Force recreate to ensure Traefik picks up new labels
            # DOMAIN_NAME is optional - used for Traefik routing labels
            # Should be just the domain name (e.g., "jarekva.com") without protocol
            # Can be set via GitHub secret DOMAIN_NAME or environment variable
            export DOMAIN_NAME=${DOMAIN_NAME:-jarekva.com}
            echo "Using DOMAIN_NAME: $DOMAIN_NAME"
            
            # Force recreate container with DOMAIN_NAME from environment
            docker compose up -d --force-recreate cursor-runner || { echo "Docker up failed"; exit 1; }
            
            # Wait a few seconds for the service to start
            echo "Waiting for service to start..."
            sleep 10
            
            # Release task operator lock (non-critical step)
            # Run from within the Docker network so it can reach cursor-agents:3002
            echo "Releasing task operator lock..."
            CURSOR_AGENTS_URL="http://cursor-agents:3002"
            # Temporarily disable exit on error for this non-critical step
            set +e
            # Check if cursor-runner container is running
            if ! docker compose ps cursor-runner | grep -q "Up"; then
              echo "⚠ cursor-runner container is not running, skipping lock release"
            else
              # Try to release the lock using Node.js (more reliable than curl)
              # Node.js is definitely available in the container
              LOCK_RESULT=$(docker compose exec -T cursor-runner node -e "
                const http = require('http');
                const url = require('url');
                const targetUrl = '${CURSOR_AGENTS_URL}/task-operator/lock';
                const parsedUrl = url.parse(targetUrl);
                const options = {
                  hostname: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: 'DELETE',
                  timeout: 5000
                };
                const req = http.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    process.stdout.write(data);
                    process.exit(res.statusCode === 200 ? 0 : 1);
                  });
                });
                req.on('error', (e) => {
                  process.stderr.write('Error: ' + e.message);
                  process.exit(1);
                });
                req.on('timeout', () => {
                  req.destroy();
                  process.stderr.write('Request timeout');
                  process.exit(1);
                });
                req.end();
              " 2>/dev/null)
              LOCK_EXIT_CODE=$?
              if [ $LOCK_EXIT_CODE -eq 0 ] && echo "$LOCK_RESULT" | grep -q '"success":true'; then
                echo "✓ Task operator lock released"
              else
                echo "⚠ Failed to release task operator lock via API (non-critical)"
                if [ -n "$LOCK_RESULT" ]; then
                  echo "  Response: $LOCK_RESULT" | head -3
                fi
                if [ $LOCK_EXIT_CODE -ne 0 ]; then
                  echo "  Exit code: $LOCK_EXIT_CODE"
                fi
              fi
            fi
            # Re-enable exit on error
            set -e
            
            echo "Deployment completed successfully"
          script_stop: true
          debug: true

