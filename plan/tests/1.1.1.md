# TASK-1.1.1: Create createMockRedisClient() Helper

**Section**: 1. Foundation & Test Infrastructure
**Subsection**: 1.1.1
**Task ID**: TASK-1.1.1
**Parent Task**: TASK-1.1

## Description

Create a reusable mock Redis client helper function that returns a fully functional mock `ioredis` instance. This helper will be used across all test files that need to interact with Redis, ensuring consistent mocking behavior and reducing test setup boilerplate.

The mock should support basic Redis operations (get, set, setex, smembers, etc.) and be able to simulate connection failures for testing error handling paths.

**Reference Implementation**: `virtual-assistant/cursor-runner/src/conversation-service.ts` (uses ioredis client)

## Current State

- `tests/test-utils.ts` exists with basic cleanup utilities
- No Redis mocking helper exists yet
- Tests that need Redis currently create their own mocks or use real Redis connections
- The `ioredis` package is used throughout the codebase for Redis operations

**Important**: This is the first helper function in Phase 1.1 and must be completed before other helpers that may depend on it.

## Checklist

### Preparation and Setup

- [ ] Review `ioredis` API documentation to understand required methods
- [ ] Review existing Redis usage in `src/conversation-service.ts` and `src/agent-conversation-service.ts`
- [ ] Review existing test files that mock Redis to understand patterns
- [ ] Understand what Redis operations are commonly used (get, set, setex, smembers, sadd, srem, etc.)

### Implementation Steps

- [ ] Step 1: Create the function signature
  - [ ] Add `createMockRedisClient()` function to `tests/test-utils.ts`
  - [ ] Define return type as `Partial<Redis>` or a custom mock interface
  - [ ] Add JSDoc comments explaining usage and parameters
- [ ] Step 2: Implement basic Redis operations
  - [ ] Implement `get(key: string): Promise<string | null>`
  - [ ] Implement `set(key: string, value: string): Promise<'OK'>`
  - [ ] Implement `setex(key: string, seconds: number, value: string): Promise<'OK'>`
  - [ ] Implement `smembers(key: string): Promise<string[]>`
  - [ ] Implement `sadd(key: string, ...members: string[]): Promise<number>`
  - [ ] Implement `srem(key: string, ...members: string[]): Promise<number>`
  - [ ] Implement `del(key: string): Promise<number>`
  - [ ] Implement `exists(key: string): Promise<number>`
  - [ ] Implement `expire(key: string, seconds: number): Promise<number>`
  - [ ] Implement `keys(pattern: string): Promise<string[]>`
- [ ] Step 3: Implement connection state simulation
  - [ ] Add `status` property that can be set to 'ready', 'connecting', 'end', 'error'
  - [ ] Add `quit()` method that returns Promise<void>
  - [ ] Add `disconnect()` method that returns Promise<void>
- [ ] Step 4: Add error simulation capability
  - [ ] Add optional parameter to simulate connection failures
  - [ ] When connection failure is simulated, methods should reject with appropriate errors
  - [ ] Add helper to reset mock state between tests

### Specific Requirements

- [ ] Requirement 1: Mock must support all Redis operations used in conversation services
  - Acceptance: All methods used in `ConversationService` and `AgentConversationService` are implemented
  - Acceptance: Methods return Promises matching ioredis API
- [ ] Requirement 2: Mock must be able to simulate connection failures
  - Acceptance: Can be configured to throw errors on all operations
  - Acceptance: Can simulate different connection states (ready, error, end)
- [ ] Requirement 3: Mock must maintain in-memory state
  - Acceptance: set/get operations work correctly
  - Acceptance: setex operations expire keys after specified time (or can be manually cleared)
  - Acceptance: Set operations (smembers, sadd, srem) work correctly
- [ ] Requirement 4: Mock must be reusable across test files
  - Acceptance: Can be imported and used in multiple test files
  - Acceptance: Each test gets a fresh mock instance (no shared state)

### Error Handling and Edge Cases

- [ ] Handle error case 1: Connection failure simulation
  - Mock should reject with Redis connection error when configured
- [ ] Handle error case 2: Key not found
  - `get()` should return `null` when key doesn't exist
  - `exists()` should return `0` when key doesn't exist
- [ ] Handle edge case 1: Empty sets and lists
  - `smembers()` should return empty array for non-existent keys
- [ ] Handle edge case 2: Multiple operations on same key
  - Operations should work correctly when called multiple times

### Testing

- [ ] Write unit tests for `createMockRedisClient()` in `tests/test-utils.test.ts`
  - [ ] Test: Returns a mock Redis client with all required methods
  - [ ] Test: `get()` returns null for non-existent keys
  - [ ] Test: `set()` and `get()` work together correctly
  - [ ] Test: `setex()` sets key with expiration
  - [ ] Test: `smembers()` returns empty array for non-existent keys
  - [ ] Test: `sadd()` and `smembers()` work together correctly
  - [ ] Test: `srem()` removes members from sets
  - [ ] Test: `del()` removes keys
  - [ ] Test: `exists()` returns 1 for existing keys, 0 for non-existent
  - [ ] Test: Connection failure simulation works (all methods reject)
  - [ ] Test: `status` property can be set and read
  - [ ] Test: `quit()` and `disconnect()` work without errors
  - [ ] Test: Multiple instances don't share state
- [ ] Run full test suite: `npm test`
- [ ] Run type checking: `npm run type-check`
- [ ] Run linting: `npm run lint`
- [ ] Verify test coverage: `npm run test:coverage`
- [ ] **DO NOT manually test by running the server** - use automated tests instead
- [ ] Ensure all helper functionality is covered by automated tests

### Documentation

- [ ] Update code comments and JSDoc/TSDoc
  - [ ] Document function purpose and usage
  - [ ] Document all parameters and return types
  - [ ] Document error simulation capabilities
  - [ ] Add usage examples in comments
- [ ] Update relevant documentation files
  - [ ] Document helper in test utilities README (if exists)
  - [ ] Add example usage in test examples

### Verification

- [ ] Verify all requirements are met
- [ ] Verify no regressions were introduced
- [ ] Verify code quality standards are met
- [ ] Review code for best practices
- [ ] Ensure proper error handling is in place
- [ ] Verify helper can be imported and used in other test files

## Notes

- This task is part of Phase 1: Foundation & Test Infrastructure
- **Execution Timing**: Must be completed before other test helpers that may use Redis mocks
- **Dependencies**: None (first helper in Phase 1.1)
- **Important Considerations**: 
  - Mock should match ioredis API as closely as possible
  - In-memory storage should be simple but functional
  - Consider using Map/Set for efficient storage
  - Don't over-engineer - focus on what's actually used in tests
- **Task Independence**: Can be completed independently
- **Current State**: No Redis mocking helper exists

## Related Tasks

- Previous: None (first subtask in Phase 1.1)
- Next: TASK-1.1.2 (createTempSqliteDb helper)
- Dependencies: None
- Related:
  - TASK-1.1: Enhance Test Utilities & Helpers (parent task)
  - TASK-11.1: ConversationService tests (will use this helper)

## Definition of Done

This task involves writing SOURCE CODE (test utility helper function and tests).

**Definition of Done**: 
1. The `createMockRedisClient()` function is implemented in `tests/test-utils.ts`
2. Unit tests for the helper are written in `tests/test-utils.test.ts` (or appropriate test file)
3. All tests pass (`npm test`)
4. Type checking passes (`npm run type-check`)
5. Linting passes (`npm run lint`)
6. Code is committed to git with descriptive commit message
7. Code is pushed to origin

**User Stories**:
- As a **test developer**, I want a reusable Redis mock helper so I don't have to create mocks in every test file
- As a **test developer**, I want to simulate Redis connection failures so I can test error handling paths
- As a **test developer**, I want the mock to support all Redis operations I use so my tests are realistic

**Automated Tests**:
- Unit tests verify all Redis operations work correctly
- Unit tests verify connection failure simulation
- Unit tests verify state isolation between instances
- All tests must pass before task is considered complete
