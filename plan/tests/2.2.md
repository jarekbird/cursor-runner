### Step 2.2: CursorRunner.initialize() - Happy Path
**Objective**: Test successful initialization flow.

This task has been broken down into granular subtasks:

1. [TASK-2.2.1](./2.2.1.md): Test initialize() calls validateConfig()
2. [TASK-2.2.2](./2.2.2.md): Test initialize() calls migrations
3. [TASK-2.2.3](./2.2.3.md): Test initialize() calls GitHubAuthService.initialize()
4. [TASK-2.2.4](./2.2.4.md): Test initialize() calls verifyMcpConfig()
5. [TASK-2.2.5](./2.2.5.md): Test initialize() calls validateGmailConfig()
6. [TASK-2.2.6](./2.2.6.md): Test initialize() calls cursorCLI.validate()
7. [TASK-2.2.7](./2.2.7.md): Test initialize() calls server.start()
8. [TASK-2.2.8](./2.2.8.md): Test initialize() logs startup messages

**Note**: Complete all subtasks in order (2.2.1 → 2.2.2 → ... → 2.2.8). Each subtask is independently completable with its own Definition of Done.

**Original Tasks**:
1. Extend `tests/index.test.ts`:
   - Add test: `initialize()` calls all dependencies in correct order:
     - `validateConfig()` (implicit)
     - `ensureSchemaMigrationsTable()` and `runMigrations()`
     - `GitHubAuthService.initialize()`
     - `verifyMcpConfig()`
     - `validateGmailConfig()`
     - `cursorCLI.validate()`
     - `server.start()`
   - Mock all dependencies and verify call order
   - Verify startup log messages are emitted

**Tests**:
- Create mocks for: migrations, `GitHubAuthService`, `cursorCLI`, `server`
- Use `jest.spyOn` or dependency injection to track calls
- Assert logs contain expected startup info

**Verification**:
- Test passes and verifies correct initialization sequence
- Logs are captured and validated
- All mocks are properly cleaned up

