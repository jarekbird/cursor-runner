### Step 4.2: POST /cursor/execute/async
**Objective**: Test asynchronous cursor execution endpoint.

This task has been broken down into granular subtasks:

1. [TASK-4.2.1](./4.2.1.md): Test POST /cursor/execute/async returns 400 when callbackUrl is missing
2. [TASK-4.2.2](./4.2.2.md): Test POST /cursor/execute/async returns 200 immediately when valid
3. [TASK-4.2.3](./4.2.3.md): Test POST /cursor/execute/async processes execution in background
4. [TASK-4.2.4](./4.2.4.md): Test POST /cursor/execute/async sends callback on success
5. [TASK-4.2.5](./4.2.5.md): Test POST /cursor/execute/async sends error callback when execution fails
6. [TASK-4.2.6](./4.2.6.md): Test POST /cursor/execute/async logs callback errors but doesn't crash

**Note**: Complete all subtasks in order (4.2.1 → 4.2.2 → 4.2.3 → 4.2.4 → 4.2.5 → 4.2.6). Each subtask is independently completable with its own Definition of Done.

**Original Tasks**:
1. Extend `tests/server.test.ts`:
   - Add test: `POST /cursor/execute/async` returns 400 when `callbackUrl` is missing
   - Add test: `POST /cursor/execute/async` returns 200 immediately when valid
   - Add test: `POST /cursor/execute/async` processes execution in background
   - Add test: `POST /cursor/execute/async` sends callback on success
   - Add test: `POST /cursor/execute/async` sends error callback when execution fails
   - Add test: `POST /cursor/execute/async` logs callback errors but doesn't crash
   - Mock `cursorExecution.execute()` and `callbackWebhook()` methods

**Tests**:
- Verify immediate 200 response
- Verify background processing happens (use `setTimeout` or `waitFor` if needed)
- Mock callback webhook and verify it's called with correct payload
- Simulate callback failure and verify it's logged but doesn't throw

**Verification**:
- Tests pass
- Async behavior works correctly
- Callbacks are sent appropriately
- Error handling is robust

