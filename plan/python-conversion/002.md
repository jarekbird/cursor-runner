# TASK-PY-002: Create Python Project Skeleton

**⚠️ CRITICAL: ALL IMPLEMENTATION CHANGES MUST BE MADE IN THE CURSOR-EXECUTOR APPLICATION ⚠️**

**Target Location**: All code changes, file creations, and modifications described in this task must be implemented in:
- **`python-cursor/cursor-executor/cursor-executor-back/`**

**DO NOT** make changes in:
- `python-cursor/cursor-runner/` (this is the Node.js reference implementation)
- Any other location

The `cursor-executor` application is the Python port target. All Python source code files, tests, configuration files, and documentation should be created or modified within the `cursor-executor-back` directory structure.

**Section**: 2. Project Setup
**Subsection**: 2.1
**Task ID**: TASK-PY-002

## Subtasks

This task has been broken down into the following granular subtasks (complete in order):

1. [TASK-PY-002.01](./002.01.md): Create Project Directory Structure
2. TASK-PY-002.02: Set up Python Packaging and Dependencies (pyproject.toml) - *To be created*
3. TASK-PY-002.03: Implement Minimal FastAPI Server with Health Endpoint - *To be created*
4. TASK-PY-002.04: Create Entry Point for Running the Server - *To be created*
5. TASK-PY-002.05: Configure Development Tooling (pytest, black, ruff, .gitignore) - *To be created*
6. TASK-PY-002.06: Write and Verify Health Endpoint Tests - *To be created*

**Note**: Complete all subtasks in order (1 → 2 → 3 → 4 → 5 → 6). Each subtask is independently completable with its own Definition of Done. The order number is also included in each subtask file header.

## Description

This task creates the foundational Python project structure for `cursor-executor`, establishing the package layout, dependencies, basic tooling configuration, and a minimal working HTTP server with a health endpoint. The skeleton provides the infrastructure needed for all subsequent implementation tasks.

The project structure will mirror the Node.js `cursor-runner` organization while following Python best practices. This includes:
- Modern Python packaging with `pyproject.toml`
- FastAPI (or Flask) web framework setup
- Package structure with logical subpackages
- Development tooling (pytest, black, ruff/flake8)
- A working `/health` endpoint to verify the server can start and respond

This skeleton serves as the foundation for all future Python implementation work and must be established before any service implementations can begin.

**Reference Implementation**: `VirtualAssistant/cursor-runner/src/server.ts` (health endpoint), `VirtualAssistant/cursor-runner/package.json` (dependencies)

## Current State

- TASK-PY-001 has been completed, establishing the baseline reference state
- The `python-cursor/cursor-runner/` directory exists but may not have Python project structure yet
- No Python package structure exists for `cursor-executor`
- No Python dependencies are defined
- No HTTP server implementation exists
- No test infrastructure is set up

**Important**: This task should be executed after TASK-PY-001 (baseline confirmation) and before any service implementation tasks.

## Checklist

### Preparation and Setup

- [ ] Review Node.js `cursor-runner` structure to understand package organization
- [ ] Review Node.js `package.json` to understand dependencies that need Python equivalents
- [ ] Review Node.js health endpoint implementation in `server.ts`
- [ ] Decide on web framework (FastAPI recommended for async support and OpenAPI)
- [ ] Verify Python 3.11+ is available in the environment
- [ ] Review master plan section 3.1 (Project structure) for target layout

### Implementation Steps

- [ ] Step 1: Create project directory structure
  - [ ] Create `cursor-executor/` directory (or confirm it exists)
  - [ ] Create `cursor_executor/` package directory (Python package root)
  - [ ] Create `cursor_executor/__init__.py` with package metadata
  - [ ] Create `cursor_executor/api/` subpackage with `__init__.py`
  - [ ] Create `cursor_executor/services/` subpackage with `__init__.py`
  - [ ] Create `cursor_executor/models/` subpackage with `__init__.py`
  - [ ] Create `cursor_executor/utils/` subpackage with `__init__.py`
  - [ ] Create `tests/` directory at project root
  - [ ] Create `tests/__init__.py`
- [ ] Step 2: Set up Python packaging and dependencies
  - [ ] Create `pyproject.toml` with project metadata:
    - [ ] Project name: `cursor-executor`
    - [ ] Python version requirement: `>=3.11`
    - [ ] Author and description
  - [ ] Add dependencies to `pyproject.toml`:
    - [ ] `fastapi` (or `flask`) for web framework
    - [ ] `uvicorn[standard]` (or `gunicorn`) for ASGI/WSGI server
    - [ ] `pydantic` and `pydantic-settings` for validation and config
    - [ ] `redis` (or `redis-py`) for Redis client
    - [ ] `pytest` and `pytest-asyncio` for testing
    - [ ] `pytest-cov` for coverage
    - [ ] `httpx` for HTTP client (callbacks)
  - [ ] Add development dependencies:
    - [ ] `black` for code formatting
    - [ ] `ruff` (or `flake8`) for linting
    - [ ] `mypy` (or `pyright`) for type checking (optional)
  - [ ] Configure build system (e.g., `setuptools` or `hatchling`)
- [ ] Step 3: Implement minimal FastAPI server
  - [ ] Create `cursor_executor/api/server.py`:
    - [ ] Import FastAPI and create app instance
    - [ ] Implement `GET /health` endpoint:
      - [ ] Return `{"status": "ok", "service": "cursor-executor"}`
      - [ ] Return HTTP 200 status
      - [ ] Log request IP and user-agent (basic logging for now)
    - [ ] Add basic request logging middleware
  - [ ] Create `cursor_executor/api/__init__.py` exporting the app
- [ ] Step 4: Create entry point
  - [ ] Create `cursor_executor/__main__.py` or `main.py`:
    - [ ] Import and run the FastAPI app with uvicorn
    - [ ] Support command-line arguments for host and port
    - [ ] Use environment variable `PORT` (default 3001 to match Node.js)
  - [ ] Or create a `run.py` script at project root
- [ ] Step 5: Configure development tooling
  - [ ] Create `pytest.ini` or configure in `pyproject.toml`:
    - [ ] Set test paths to `tests/`
    - [ ] Configure asyncio mode if using async endpoints
    - [ ] Set coverage options
  - [ ] Create `pyproject.toml` tool configuration:
    - [ ] `[tool.black]` section with line length and target version
    - [ ] `[tool.ruff]` section (or `.flake8` file) with linting rules
    - [ ] `[tool.pytest.ini_options]` section if using pyproject.toml
  - [ ] Create `.gitignore` file:
    - [ ] Python-specific ignores (`__pycache__/`, `*.pyc`, `.pytest_cache/`, etc.)
    - [ ] Virtual environment directories
    - [ ] IDE-specific files
    - [ ] Environment files (`.env`)

### Specific Requirements

- [ ] Requirement 1: Project structure matches master plan
  - Acceptance criteria: All subpackages (`api/`, `services/`, `models/`, `utils/`) exist with `__init__.py`
  - Acceptance criteria: `tests/` directory exists at project root
  - Acceptance criteria: Package structure allows for logical organization of future code
- [ ] Requirement 2: Dependencies are properly defined
  - Acceptance criteria: `pyproject.toml` includes all required runtime dependencies
  - Acceptance criteria: Development dependencies are separated or clearly marked
  - Acceptance criteria: Python version requirement is specified (>=3.11)
- [ ] Requirement 3: Health endpoint works correctly
  - Acceptance criteria: `GET /health` returns HTTP 200
  - Acceptance criteria: Response body matches `{"status": "ok", "service": "cursor-executor"}`
  - Acceptance criteria: Server can start without errors
  - Acceptance criteria: Basic request logging occurs
- [ ] Requirement 4: Development tooling is configured
  - Acceptance criteria: `pytest` can discover and run tests
  - Acceptance criteria: `black` can format code
  - Acceptance criteria: Linter (ruff/flake8) can check code
  - Acceptance criteria: `.gitignore` prevents committing unnecessary files

### Error Handling and Edge Cases

- [ ] Handle case where Python 3.11+ is not available: Document minimum version requirement and provide upgrade instructions
- [ ] Handle case where dependencies fail to install: Document system requirements and provide troubleshooting
- [ ] Handle case where port is already in use: Server should fail with clear error message
- [ ] Handle case where health endpoint receives malformed requests: Server should handle gracefully
- [ ] Handle case where package structure conflicts with existing files: Document and resolve conflicts

### Testing

- [ ] Write `tests/test_health_endpoint.py`:
  - [ ] Test that health endpoint returns 200 status
  - [ ] Test that response body matches expected structure
  - [ ] Test that response includes correct service name
  - [ ] Use FastAPI TestClient or httpx for testing
- [ ] Write `tests/test_server_startup.py`:
  - [ ] Test that server can be instantiated
  - [ ] Test that server can start (optional, may require async test setup)
- [ ] Run `pytest` and ensure all tests pass
- [ ] Verify test discovery works: `pytest --collect-only`
- [ ] **DO NOT manually test by running the server** - use automated tests instead
- [ ] Ensure test structure mirrors Node.js test organization

### Documentation

- [ ] Create or update `README.md` in `cursor-executor/`:
  - [ ] Project description and purpose
  - [ ] Installation instructions (pip install -e . or poetry install)
  - [ ] Running the server locally
  - [ ] Running tests
  - [ ] Development setup
- [ ] Document environment variables needed (at minimum `PORT`)
- [ ] Add code comments to `server.py` explaining the health endpoint
- [ ] Document the package structure and organization rationale

### Verification

- [ ] Verify project structure matches master plan requirements
- [ ] Verify all dependencies can be installed: `pip install -e .` (or equivalent)
- [ ] Verify health endpoint test passes
- [ ] Verify server can be started manually (for verification only, not as part of DoD)
- [ ] Verify development tooling works (pytest, black, linter)
- [ ] Verify `.gitignore` prevents committing build artifacts

## Notes

- This task is part of Phase 2: Project Setup
- **Execution Timing**: Execute after TASK-PY-001 (baseline confirmation), before any service implementation
- **Dependencies**: 
  - TASK-PY-001: Confirm Baseline `cursor-runner` State (must be complete)
- **Important Considerations**: 
  - FastAPI is recommended over Flask for better async support and automatic OpenAPI documentation
  - Package structure should allow for easy addition of new services and modules
  - Development tooling configuration should match team standards and be consistent
  - Health endpoint should match Node.js behavior exactly for compatibility
- **Task Independence**: This task can be completed independently after baseline is established
- **Current State**: No Python project structure exists yet

## Related Tasks

- Previous: TASK-PY-001 (Confirm Baseline `cursor-runner` State)
- Next: TASK-PY-003 (Implement Configuration & Settings Module)
- Dependencies:
  - TASK-PY-001: Baseline must be established to understand reference structure
- Related:
  - TASK-PY-003: Will use the project structure created here
  - TASK-PY-004: Will add logging to the server created here
  - TASK-PY-014: Will expand the API layer started here

## Definition of Done

This task involves **CODE/FILE WRITING** - creating Python source code files and project configuration.

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**User Stories**:
- As a **Python developer**, I need a well-structured project skeleton so I can organize code logically as I implement services
- As a **developer**, I need a working health endpoint so I can verify the server starts and responds correctly
- As a **developer**, I need configured development tooling so I can write, format, lint, and test code consistently
- As a **CI/CD system**, I need a testable health endpoint so I can verify deployments are working

**Automated Tests**:
- `tests/test_health_endpoint.py`:
  - Test health endpoint returns HTTP 200
  - Test health endpoint response body structure: `{"status": "ok", "service": "cursor-executor"}`
  - Test health endpoint can be called via TestClient
- `tests/test_server_startup.py`:
  - Test FastAPI app can be instantiated
  - Test app includes health route
- All tests must pass: `pytest tests/ -v`
- Test coverage should be measured (aim for >80% on new code)

**Commit and Push Requirements**:
- [ ] Stage all new files: `git add cursor-executor/ pyproject.toml pytest.ini .gitignore README.md`
- [ ] Commit with descriptive message: `git commit -m "TASK-PY-002: Create Python project skeleton with health endpoint

- Add pyproject.toml with FastAPI and dependencies
- Create package structure (api/, services/, models/, utils/)
- Implement GET /health endpoint
- Configure pytest, black, and ruff
- Add tests for health endpoint"`
- [ ] Push to origin: `git push origin <branch-name>`
- [ ] Verify commit appears in remote repository
- [ ] Verify CI/CD (if configured) runs tests successfully

**Completion Criteria**:
- [ ] Python project skeleton exists with proper package structure
- [ ] `/health` endpoint works and returns expected response
- [ ] Test for health endpoint passes
- [ ] Development tooling (pytest, black, linter) is configured and working
- [ ] All code is committed and pushed to origin
- [ ] Project can be installed: `pip install -e .` succeeds
